{"ast":null,"code":"import hyphenate from \"./hyphenate-style-name\";\nimport { validateNoMixedHand } from \"./validate-no-mixed-hand\";\nimport { prefix } from \"inline-style-prefixer\";\nimport { MultiCache } from \"./cache\";\nexport default function injectStylePrefixed(styleCache, styles, media, pseudo) {\n  const cache = styleCache.getCache(media);\n  let classString = \"\";\n  for (const originalKey in styles) {\n    const originalVal = styles[originalKey];\n    if (originalVal === void 0 || originalVal === null) {\n      continue;\n    }\n    if (typeof originalVal !== \"object\") {\n      // Non-null and non-undefined primitive value\n      if (process.env.NODE_ENV !== \"production\") {\n        validateValueType(originalVal, originalKey);\n      }\n      const propValPair = \"\".concat(hyphenate(originalKey), \":\").concat(originalVal);\n      const key = \"\".concat(pseudo).concat(propValPair);\n      const cachedId = cache.cache[key];\n      if (cachedId !== void 0) {\n        // cache hit\n        classString += \" \" + cachedId;\n        continue;\n      } else {\n        // cache miss\n        let block = \"\";\n        const prefixed = prefix({\n          [originalKey]: originalVal\n        });\n        for (const prefixedKey in prefixed) {\n          const prefixedVal = prefixed[prefixedKey];\n          const prefixedValType = typeof prefixedVal;\n          if (prefixedValType === \"string\" || prefixedValType === \"number\") {\n            const prefixedPair = \"\".concat(hyphenate(prefixedKey), \":\").concat(prefixedVal);\n            if (prefixedPair !== propValPair) {\n              block += \"\".concat(prefixedPair, \";\");\n            }\n          } else if (Array.isArray(prefixedVal)) {\n            const hyphenated = hyphenate(prefixedKey);\n            for (let i = 0; i < prefixedVal.length; i++) {\n              const prefixedPair = \"\".concat(hyphenated, \":\").concat(prefixedVal[i]);\n              if (prefixedPair !== propValPair) {\n                block += \"\".concat(prefixedPair, \";\");\n              }\n            }\n          }\n        }\n        block += propValPair; // ensure original prop/val is last (for hydration)\n\n        const id = cache.addValue(key, {\n          pseudo,\n          block\n        });\n        classString += \" \" + id;\n      }\n    } else {\n      // Non-null object value\n      if (originalKey[0] === \":\") {\n        classString += \" \" + injectStylePrefixed(styleCache, originalVal, media, pseudo + originalKey);\n      } else if (originalKey.substring(0, 6) === \"@media\") {\n        classString += \" \" + injectStylePrefixed(styleCache, originalVal, originalKey.substr(7), pseudo);\n      }\n    }\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    const conflicts = validateNoMixedHand(styles);\n    if (conflicts.length) {\n      conflicts.forEach(_ref => {\n        let {\n          shorthand,\n          longhand\n        } = _ref;\n        const short = JSON.stringify({\n          [shorthand.property]: shorthand.value\n        });\n        const long = JSON.stringify({\n          [longhand.property]: longhand.value\n        }); // eslint-disable-next-line no-console\n\n        console.warn(\"Styles `\".concat(short, \"` and `\").concat(long, \"` in object yielding class \\\"\").concat(classString.slice(1), \"\\\" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.\"));\n      });\n    }\n  } // remove leading space\n\n  return classString.slice(1);\n}\nfunction validateValueType(value, key) {\n  if (value === null || Array.isArray(value) || typeof value !== \"number\" && typeof value !== \"string\") {\n    throw new Error(\"Unsupported style value: \".concat(JSON.stringify(value), \" used in property \").concat(JSON.stringify(key)));\n  }\n}","map":{"version":3,"sources":["src/inject-style-prefixed.ts"],"names":["hyphenate","validateNoMixedHand","prefix","MultiCache","injectStylePrefixed","styleCache","styles","media","pseudo","cache","getCache","classString","originalKey","originalVal","validateValueType","propValPair","key","cachedId","block","prefixed","prefixedKey","prefixedVal","prefixedValType","prefixedPair","Array","isArray","hyphenated","i","length","id","addValue","substring","substr","conflicts","forEach","shorthand","longhand","short","stringify","property","value","long","console","warn","slice","Error","JSON"],"mappings":"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","sourcesContent":["declare var __DEV__: boolean;\n\nimport hyphenate from \"./hyphenate-style-name\";\nimport {validateNoMixedHand} from \"./validate-no-mixed-hand\";\nimport {prefix} from \"inline-style-prefixer\";\n\nimport type {StyleObject} from \"styletron-standard\";\n\nimport {MultiCache} from \"./cache\";\n\nexport default function injectStylePrefixed(\n  styleCache: MultiCache<{\n    pseudo: string;\n    block: string;\n  }>,\n  styles: StyleObject,\n  media: string,\n  pseudo: string,\n) {\n  const cache = styleCache.getCache(media);\n  let classString = \"\";\n  for (const originalKey in styles) {\n    const originalVal = styles[originalKey];\n\n    if (originalVal === void 0 || originalVal === null) {\n      continue;\n    }\n    if (typeof originalVal !== \"object\") {\n      // Non-null and non-undefined primitive value\n      if (__DEV__) {\n        validateValueType(originalVal, originalKey);\n      }\n\n      const propValPair = `${hyphenate(originalKey)}:${\n        originalVal as any as string\n      }`;\n      const key = `${pseudo}${propValPair}`;\n      const cachedId = cache.cache[key];\n      if (cachedId !== void 0) {\n        // cache hit\n        classString += \" \" + cachedId;\n        continue;\n      } else {\n        // cache miss\n        let block = \"\";\n        const prefixed = prefix({[originalKey]: originalVal});\n        for (const prefixedKey in prefixed) {\n          const prefixedVal = prefixed[prefixedKey];\n          const prefixedValType = typeof prefixedVal;\n          if (prefixedValType === \"string\" || prefixedValType === \"number\") {\n            const prefixedPair = `${hyphenate(prefixedKey)}:${prefixedVal}`;\n            if (prefixedPair !== propValPair) {\n              block += `${prefixedPair};`;\n            }\n          } else if (Array.isArray(prefixedVal)) {\n            const hyphenated = hyphenate(prefixedKey);\n            for (let i = 0; i < prefixedVal.length; i++) {\n              const prefixedPair = `${hyphenated}:${prefixedVal[i]}`;\n              if (prefixedPair !== propValPair) {\n                block += `${prefixedPair};`;\n              }\n            }\n          }\n        }\n        block += propValPair; // ensure original prop/val is last (for hydration)\n        const id = cache.addValue(key, {pseudo, block});\n        classString += \" \" + id;\n      }\n    } else {\n      // Non-null object value\n      if (originalKey[0] === \":\") {\n        classString +=\n          \" \" +\n          injectStylePrefixed(\n            styleCache,\n            originalVal as StyleObject,\n            media,\n            pseudo + originalKey,\n          );\n      } else if (originalKey.substring(0, 6) === \"@media\") {\n        classString +=\n          \" \" +\n          injectStylePrefixed(\n            styleCache,\n            originalVal as StyleObject,\n            originalKey.substr(7),\n            pseudo,\n          );\n      }\n    }\n  }\n\n  if (__DEV__) {\n    const conflicts = validateNoMixedHand(styles);\n    if (conflicts.length) {\n      conflicts.forEach(({shorthand, longhand}) => {\n        const short = JSON.stringify({[shorthand.property]: shorthand.value});\n        const long = JSON.stringify({[longhand.property]: longhand.value});\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Styles \\`${short}\\` and \\`${long}\\` in object yielding class \"${classString.slice(\n            1,\n          )}\" may result in unexpected behavior. Mixing shorthand and longhand properties within the same style object is unsupported with atomic rendering.`,\n        );\n      });\n    }\n  }\n\n  // remove leading space\n  return classString.slice(1);\n}\n\nfunction validateValueType(value, key) {\n  if (\n    value === null ||\n    Array.isArray(value) ||\n    (typeof value !== \"number\" && typeof value !== \"string\")\n  ) {\n    throw new Error(\n      `Unsupported style value: ${JSON.stringify(\n        value,\n      )} used in property ${JSON.stringify(key)}`,\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}