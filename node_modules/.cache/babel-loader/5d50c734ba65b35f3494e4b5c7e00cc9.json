{"ast":null,"code":"/* eslint-env browser */\nconst STYLES_HYDRATOR = /\\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;\nconst KEYFRAMES_HYRDATOR = /@keyframes ([^{]+){((?:(?:from|to|(?:\\d+\\.?\\d*%))\\{(?:[^}])*})*)}/g;\nconst FONT_FACE_HYDRATOR = /@font-face\\{font-family:([^;]+);([^}]*)\\}/g;\nfunction hydrateStyles(cache, hydrator, css) {\n  let match;\n  while (match = hydrator.exec(css)) {\n    const [, id, pseudo, key] = match;\n    if (true && process.env.NODE_ENV !== \"production\" && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n    const fullKey = pseudo ? `${pseudo}${key}` : key;\n    cache.cache[fullKey] = id; // set cache without triggering side effects\n\n    cache.idGenerator.increment(); // increment id\n  }\n}\nfunction hydrate(cache, hydrator, css) {\n  let match;\n  while (match = hydrator.exec(css)) {\n    const [, id, key] = match;\n    if (true && process.env.NODE_ENV !== \"production\" && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n    cache.cache[key] = id; // set cache without triggering side effects\n\n    cache.idGenerator.increment(); // increment id\n  }\n}\nimport SequentialIDGenerator from \"../sequential-id-generator\";\nimport { Cache, MultiCache } from \"../cache\";\nimport injectStylePrefixed from \"../inject-style-prefixed\";\nimport { styleBlockToRule, atomicSelector, keyframesBlockToRule, declarationsToBlock, keyframesToBlock, fontFaceBlockToRule } from \"../css\";\nimport { insertRuleIntoDevtools, hydrateDevtoolsRule } from \"../dev-tool\";\nclass StyletronClient {\n  constructor(opts = {}) {\n    this.styleElements = {};\n    const styleIdGenerator = new SequentialIDGenerator(opts.prefix);\n    const onNewStyle = (cache, id, value) => {\n      const {\n        pseudo,\n        block\n      } = value;\n      const sheet = this.styleElements[cache.key].sheet;\n      const selector = atomicSelector(id, pseudo);\n      const rule = styleBlockToRule(selector, block);\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n        if (true && process.env.NODE_ENV !== \"production\" && window.__STYLETRON_DEVTOOLS__) {\n          insertRuleIntoDevtools(selector, block);\n        }\n      } catch (e) {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(`Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`);\n        }\n      }\n    }; // Setup style cache\n\n    this.styleCache = new MultiCache(styleIdGenerator, (media, _cache, insertBeforeMedia) => {\n      const styleElement = document.createElement(\"style\");\n      styleElement.media = media;\n      if (insertBeforeMedia === void 0) {\n        this.container.appendChild(styleElement);\n      } else {\n        const insertBeforeIndex = findSheetIndexWithMedia(this.container.children, insertBeforeMedia);\n        this.container.insertBefore(styleElement, this.container.children[insertBeforeIndex]);\n      }\n      this.styleElements[media] = styleElement;\n    }, onNewStyle);\n    this.keyframesCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.styleCache.getCache(\"\");\n      const sheet = this.styleElements[\"\"].sheet;\n      const rule = keyframesBlockToRule(id, keyframesToBlock(value));\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n      } catch (e) {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(`Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`);\n        }\n      }\n    });\n    this.fontFaceCache = new Cache(new SequentialIDGenerator(opts.prefix), (cache, id, value) => {\n      this.styleCache.getCache(\"\");\n      const sheet = this.styleElements[\"\"].sheet;\n      const rule = fontFaceBlockToRule(id, declarationsToBlock(value));\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n      } catch (e) {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(`Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`);\n        }\n      }\n    });\n    if (opts.container) {\n      this.container = opts.container;\n    } // Hydrate\n\n    if (opts.hydrate && opts.hydrate.length > 0) {\n      // infer container from parent element\n      if (!this.container) {\n        const parentElement = opts.hydrate[0].parentElement;\n        if (parentElement !== null && parentElement !== void 0) {\n          this.container = parentElement;\n        }\n      }\n      for (let i = 0; i < opts.hydrate.length; i++) {\n        const element = opts.hydrate[i];\n        const hydrateType = element.getAttribute(\"data-hydrate\");\n        if (hydrateType === \"font-face\") {\n          hydrate(this.fontFaceCache, FONT_FACE_HYDRATOR, element.textContent);\n          continue;\n        }\n        if (hydrateType === \"keyframes\") {\n          hydrate(this.keyframesCache, KEYFRAMES_HYRDATOR, element.textContent);\n          continue;\n        }\n        const key = element.media ? element.media : \"\";\n        this.styleElements[key] = element;\n        const cache = new Cache(styleIdGenerator, onNewStyle);\n        cache.key = key;\n        hydrateStyles(cache, STYLES_HYDRATOR, element.textContent);\n        this.styleCache.sortedCacheKeys.push(key);\n        this.styleCache.caches[key] = cache;\n      }\n    }\n    if (!this.container) {\n      if (document.head === null) {\n        throw new Error(\"No container provided and `document.head` was null\");\n      }\n      this.container = document.head;\n    }\n  }\n  renderStyle(style) {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n  renderFontFace(fontFace) {\n    const key = declarationsToBlock(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n  renderKeyframes(keyframes) {\n    const key = keyframesToBlock(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n}\nexport default StyletronClient;\nfunction findSheetIndexWithMedia(children, media) {\n  let index = 0;\n  for (; index < children.length; index++) {\n    const child = children[index];\n    if (child.tagName === \"STYLE\" && child.media === media) {\n      return index;\n    }\n  }\n  return -1;\n}","map":{"version":3,"sources":["src/client/client.ts"],"names":["STYLES_HYDRATOR","KEYFRAMES_HYRDATOR","FONT_FACE_HYDRATOR","hydrateStyles","cache","hydrator","css","match","exec","id","pseudo","key","window","__STYLETRON_DEVTOOLS__","hydrateDevtoolsRule","fullKey","idGenerator","increment","hydrate","SequentialIDGenerator","Cache","MultiCache","injectStylePrefixed","styleBlockToRule","atomicSelector","keyframesBlockToRule","declarationsToBlock","keyframesToBlock","fontFaceBlockToRule","insertRuleIntoDevtools","StyletronClient","constructor","opts","styleElements","styleIdGenerator","prefix","onNewStyle","value","block","sheet","selector","rule","insertRule","cssRules","length","e","console","warn","styleCache","media","_cache","insertBeforeMedia","styleElement","document","createElement","container","appendChild","insertBeforeIndex","findSheetIndexWithMedia","children","insertBefore","keyframesCache","getCache","fontFaceCache","parentElement","i","element","hydrateType","getAttribute","textContent","sortedCacheKeys","push","caches","head","Error","renderStyle","style","renderFontFace","fontFace","addValue","renderKeyframes","keyframes","index","child","tagName"],"mappings":"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","sourcesContent":["/* eslint-env browser */\n\ndeclare var __DEV__: boolean;\n\ndeclare var __BROWSER__: boolean;\n\nconst STYLES_HYDRATOR = /\\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;\nconst KEYFRAMES_HYRDATOR =\n  /@keyframes ([^{]+){((?:(?:from|to|(?:\\d+\\.?\\d*%))\\{(?:[^}])*})*)}/g;\nconst FONT_FACE_HYDRATOR = /@font-face\\{font-family:([^;]+);([^}]*)\\}/g;\n\ntype hydratorT =\n  | typeof STYLES_HYDRATOR\n  | typeof KEYFRAMES_HYRDATOR\n  | typeof FONT_FACE_HYDRATOR;\n\nfunction hydrateStyles<T>(cache: Cache<T>, hydrator: hydratorT, css: string) {\n  let match;\n  while ((match = hydrator.exec(css))) {\n    const [, id, pseudo, key] = match;\n    if (__BROWSER__ && __DEV__ && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n    const fullKey = pseudo ? `${pseudo}${key}` : key;\n    cache.cache[fullKey] = id; // set cache without triggering side effects\n    cache.idGenerator.increment(); // increment id\n  }\n}\n\nfunction hydrate<T>(cache: Cache<T>, hydrator: hydratorT, css: string) {\n  let match;\n  while ((match = hydrator.exec(css))) {\n    const [, id, key] = match;\n    if (__BROWSER__ && __DEV__ && window.__STYLETRON_DEVTOOLS__) {\n      hydrateDevtoolsRule(match[0]);\n    }\n    cache.cache[key] = id; // set cache without triggering side effects\n    cache.idGenerator.increment(); // increment id\n  }\n}\n\nimport SequentialIDGenerator from \"../sequential-id-generator\";\n\nimport type {\n  StandardEngine,\n  KeyframesObject,\n  FontFaceObject,\n  StyleObject,\n} from \"styletron-standard\";\n\nimport {Cache, MultiCache} from \"../cache\";\n\nimport injectStylePrefixed from \"../inject-style-prefixed\";\n\nimport {\n  styleBlockToRule,\n  atomicSelector,\n  keyframesBlockToRule,\n  declarationsToBlock,\n  keyframesToBlock,\n  fontFaceBlockToRule,\n} from \"../css\";\nimport {insertRuleIntoDevtools, hydrateDevtoolsRule} from \"../dev-tool\";\n\ntype hydrateT =\n  | HTMLCollectionOf<HTMLStyleElement>\n  | Array<HTMLStyleElement>\n  | NodeListOf<HTMLStyleElement>;\n\ntype optionsT = {\n  hydrate?: hydrateT;\n  container?: Element;\n  prefix?: string;\n};\n\nclass StyletronClient implements StandardEngine {\n  container: Element;\n  styleElements: {\n    [x: string]: HTMLStyleElement;\n  };\n  fontFaceSheet: HTMLStyleElement;\n  keyframesSheet: HTMLStyleElement;\n\n  styleCache: MultiCache<{\n    pseudo: string;\n    block: string;\n  }>;\n  keyframesCache: Cache<KeyframesObject>;\n  fontFaceCache: Cache<FontFaceObject>;\n\n  constructor(opts: optionsT = {}) {\n    this.styleElements = {};\n\n    const styleIdGenerator = new SequentialIDGenerator(opts.prefix);\n    const onNewStyle = (cache, id, value) => {\n      const {pseudo, block} = value;\n      const sheet: CSSStyleSheet = this.styleElements[cache.key].sheet as any;\n      const selector = atomicSelector(id, pseudo);\n      const rule = styleBlockToRule(selector, block);\n      try {\n        sheet.insertRule(rule, sheet.cssRules.length);\n        if (__BROWSER__ && __DEV__ && window.__STYLETRON_DEVTOOLS__) {\n          insertRuleIntoDevtools(selector, block);\n        }\n      } catch (e) {\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`,\n          );\n        }\n      }\n    };\n\n    // Setup style cache\n    this.styleCache = new MultiCache(\n      styleIdGenerator,\n      (media, _cache, insertBeforeMedia) => {\n        const styleElement = document.createElement(\"style\");\n        styleElement.media = media;\n        if (insertBeforeMedia === void 0) {\n          this.container.appendChild(styleElement);\n        } else {\n          const insertBeforeIndex = findSheetIndexWithMedia(\n            this.container.children,\n            insertBeforeMedia,\n          );\n          this.container.insertBefore(\n            styleElement,\n            this.container.children[insertBeforeIndex],\n          );\n        }\n\n        this.styleElements[media] = styleElement;\n      },\n      onNewStyle,\n    );\n\n    this.keyframesCache = new Cache(\n      new SequentialIDGenerator(opts.prefix),\n      (cache, id, value) => {\n        this.styleCache.getCache(\"\");\n        const sheet: CSSStyleSheet = this.styleElements[\"\"].sheet as any;\n        const rule = keyframesBlockToRule(id, keyframesToBlock(value));\n        try {\n          sheet.insertRule(rule, sheet.cssRules.length);\n        } catch (e) {\n          if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`,\n            );\n          }\n        }\n      },\n    );\n\n    this.fontFaceCache = new Cache(\n      new SequentialIDGenerator(opts.prefix),\n      (cache, id, value) => {\n        this.styleCache.getCache(\"\");\n        const sheet: CSSStyleSheet = this.styleElements[\"\"].sheet as any;\n        const rule = fontFaceBlockToRule(id, declarationsToBlock(value));\n        try {\n          sheet.insertRule(rule, sheet.cssRules.length);\n        } catch (e) {\n          if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `Failed to inject CSS: \"${rule}\". Perhaps this has invalid or un-prefixed properties?`,\n            );\n          }\n        }\n      },\n    );\n\n    if (opts.container) {\n      this.container = opts.container;\n    }\n\n    // Hydrate\n    if (opts.hydrate && opts.hydrate.length > 0) {\n      // infer container from parent element\n      if (!this.container) {\n        const parentElement = opts.hydrate[0].parentElement;\n        if (parentElement !== null && parentElement !== void 0) {\n          this.container = parentElement;\n        }\n      }\n\n      for (let i = 0; i < opts.hydrate.length; i++) {\n        const element = opts.hydrate[i];\n        const hydrateType = element.getAttribute(\"data-hydrate\");\n        if (hydrateType === \"font-face\") {\n          hydrate(this.fontFaceCache, FONT_FACE_HYDRATOR, element.textContent);\n          continue;\n        }\n        if (hydrateType === \"keyframes\") {\n          hydrate(this.keyframesCache, KEYFRAMES_HYRDATOR, element.textContent);\n          continue;\n        }\n        const key = element.media ? element.media : \"\";\n        this.styleElements[key] = element;\n        const cache = new Cache(styleIdGenerator, onNewStyle);\n        cache.key = key;\n        hydrateStyles(cache, STYLES_HYDRATOR, element.textContent);\n        this.styleCache.sortedCacheKeys.push(key);\n        this.styleCache.caches[key] = cache;\n      }\n    }\n\n    if (!this.container) {\n      if (document.head === null) {\n        throw new Error(\"No container provided and `document.head` was null\");\n      }\n      this.container = document.head;\n    }\n  }\n\n  renderStyle(style: StyleObject): string {\n    return injectStylePrefixed(this.styleCache, style, \"\", \"\");\n  }\n\n  renderFontFace(fontFace: FontFaceObject): string {\n    const key = declarationsToBlock(fontFace);\n    return this.fontFaceCache.addValue(key, fontFace);\n  }\n\n  renderKeyframes(keyframes: KeyframesObject): string {\n    const key = keyframesToBlock(keyframes);\n    return this.keyframesCache.addValue(key, keyframes);\n  }\n}\n\nexport default StyletronClient;\n\nfunction findSheetIndexWithMedia(children, media) {\n  let index = 0;\n  for (; index < children.length; index++) {\n    const child = children[index];\n    if (\n      child.tagName === \"STYLE\" &&\n      (child as any as HTMLStyleElement).media === media\n    ) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n"]},"metadata":{},"sourceType":"module"}